<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RunningGamePhase.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">TimeGuess</a> &gt; <a href="index.source.html" class="el_package">at.qe.timeguess.gamelogic</a> &gt; <span class="el_source">RunningGamePhase.java</span></div><h1>RunningGamePhase.java</h1><pre class="source lang-java linenums">package at.qe.timeguess.gamelogic;

import at.qe.timeguess.model.Expression;
import at.qe.timeguess.model.User;
import at.qe.timeguess.websockDto.BatteryUpdateDTO;
import at.qe.timeguess.websockDto.DiceConnectionUpdateDTO;
import at.qe.timeguess.websockDto.FinishedGameDTO;
import at.qe.timeguess.websockDto.ScoreUpdateDTO;

import java.util.Collections;
import java.util.Random;
import java.util.Set;
import java.util.TreeSet;

public class RunningGamePhase {

    private Game game;
    private int currentTeam;
    private int roundCounter;
    private Integer currentFacet;
    private Set&lt;Long&gt; usedExpressions;
    private Expression currentExpression;
    private Long roundStartTime;
    private Long roundEndTime;
    private long gameStartTime;
    private boolean expressionConfirmed;

<span class="fc" id="L28">    protected  RunningGamePhase(Game game){</span>
<span class="fc" id="L29">        this.usedExpressions = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L30">        this.game = game;</span>
<span class="fc" id="L31">    }</span>

    /**
     * Method that starts the game and sets it up for the first round.
     */
    protected void startGame() {
<span class="fc" id="L37">        game.setActive(true);</span>
<span class="fc" id="L38">        expressionConfirmed = false;</span>
<span class="fc" id="L39">        currentFacet = null;</span>
<span class="fc" id="L40">        gameStartTime = System.currentTimeMillis() / 1000L;</span>
<span class="fc" id="L41">        currentTeam = new Random().nextInt(game.getNumberOfTeams());</span>
<span class="fc" id="L42">        roundCounter = 1;</span>
<span class="pc bpc" id="L43" title="1 of 2 branches missed.">        if (!pickNewExpression()) {</span>
<span class="nc" id="L44">            finishGame(true);</span>
        }
<span class="fc" id="L46">        roundStartTime = -1L;</span>
<span class="fc" id="L47">        roundEndTime = -1L;</span>
<span class="fc" id="L48">        game.getWebSocketService().sendCompleteGameUpdateToFrontend(game.getGameCode(), game.getDtoFactory().buildStateUpdate(game));</span>
<span class="fc" id="L49">    }</span>

    /**
     * Method that handles incoming facet updates from the rasperry.
     * @param facet the new facet received by the raspberry.
     */
    protected void diceUpdate(final int facet) {
<span class="pc bpc" id="L56" title="1 of 4 branches missed.">        if (roundStartTime == -1 &amp;&amp; game.getDice().isRaspberryConnected()) {</span>
            // between round phase - start timer
<span class="fc" id="L58">            roundStartTime = System.currentTimeMillis() / 1000L;</span>
<span class="fc" id="L59">            currentFacet = facet;</span>
<span class="fc" id="L60">            sendRunningDataToTeams();</span>

        } else {
<span class="pc bpc" id="L63" title="3 of 6 branches missed.">            if (roundStartTime != -1L &amp;&amp; roundEndTime == -1L &amp;&amp; game.getDice().isRaspberryConnected()) {</span>
<span class="fc" id="L64">                roundEndTime = System.currentTimeMillis() / 1000L;</span>
<span class="fc" id="L65">                sendRunningDataToTeams();</span>
            }
        }
<span class="fc" id="L68">    }</span>


    /**
     * Method that contains the main logic for deciding whether a player guess the expression correctly and how many
     * points are added to the team scores.
     * @param decision decision, whether an expression got guessed correctly. Has one of the three values: CORRECT, INVALID or WRONG
     */
    protected synchronized void confirmExpression(final String decision) {
<span class="pc bpc" id="L77" title="2 of 6 branches missed.">        if (roundStartTime != -1 &amp;&amp; !expressionConfirmed &amp;&amp; game.getDice().isRaspberryConnected()) {</span>
<span class="fc" id="L78">            expressionConfirmed = true;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">            if (decision.equals(&quot;CORRECT&quot;)) {</span>
<span class="fc" id="L80">                correctGuessAction();</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">                if (game.getTeams().get(currentTeam).getScore() &gt;= game.getMaxPoints()) {</span>
<span class="nc" id="L82">                    finishGame(false);</span>
<span class="nc" id="L83">                    return;</span>
                }
<span class="fc bfc" id="L85" title="All 2 branches covered.">            } else if (decision.equals(&quot;INVALID&quot;)) {</span>
<span class="fc" id="L86">                invalidGuessAction();</span>
            } else {
<span class="fc" id="L88">                wrongGuessAction();</span>
            }
<span class="fc" id="L90">            start_new_round();</span>
        }
<span class="fc" id="L92">    }</span>

    /**
     * Method that gets called when a guess is correct. Adds points and notifies players accordingly
     */
    private void correctGuessAction(){
<span class="fc" id="L98">        game.getTeams().get(currentTeam).incrementScore(game.getDice().getPoints(currentFacet));</span>
<span class="fc" id="L99">        game.getTeams().get(currentTeam).incrementCorrectExpressions();</span>
<span class="fc" id="L100">        game.getWebSocketService().sendScoreChangeToFrontend(game.getGameCode(),</span>
<span class="fc" id="L101">            new ScoreUpdateDTO(currentTeam, game.getTeams().get(currentTeam).getScore()));</span>
<span class="fc" id="L102">    }</span>

    /**
     * Method that gets called when a guess is invalid. Adds points and notifies players accordingly
     */
    private void invalidGuessAction(){
<span class="fc" id="L108">        game.getTeams().get(currentTeam).decrementScore(1);</span>
<span class="fc" id="L109">        game.getTeams().get(currentTeam).incrementWrongExpressions();</span>
<span class="fc" id="L110">        game.getWebSocketService().sendScoreChangeToFrontend(game.getGameCode(),</span>
<span class="fc" id="L111">            new ScoreUpdateDTO(currentTeam, game.getTeams().get(currentTeam).getScore()));</span>
<span class="fc" id="L112">    }</span>

    /**
     * Method that gets called when a guess is wrong. Adds points and notifies players accordingly
     */
    private void wrongGuessAction(){
<span class="fc" id="L118">        game.getTeams().get(currentTeam).incrementWrongExpressions();</span>
<span class="fc" id="L119">    }</span>

    /**
     * Method that starts a new round after a guess was made.
     */
    private void start_new_round(){
<span class="fc" id="L125">        game.getTeams().get(currentTeam).incrementCurrentPlayer();</span>
<span class="fc" id="L126">        incrementCurrentTeam();</span>
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        if (!pickNewExpression()) {</span>
<span class="nc" id="L128">            finishGame(true);</span>
        }
<span class="fc" id="L130">        currentFacet = null;</span>
<span class="fc" id="L131">        roundStartTime = -1L;</span>
<span class="fc" id="L132">        roundEndTime = -1L;</span>
<span class="fc" id="L133">        expressionConfirmed = false;</span>
<span class="fc" id="L134">        roundCounter++;</span>
<span class="fc" id="L135">        sendRunningDataToTeams();</span>
<span class="fc" id="L136">    }</span>

    /**
     * Method that finishes the game properly. Users get notified of an early end if
     * no expressions are left in the category.
     */
    protected void finishGame(final boolean earlyFinish) {
<span class="nc" id="L143">        final long endTime = System.currentTimeMillis() / 1000L;</span>
<span class="nc" id="L144">        game.setActive(false);</span>
<span class="nc" id="L145">        Collections.sort(game.getTeams(), (o1, o2) -&gt; {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">            if (o1.getScore() &lt; o2.getScore()) {</span>
<span class="nc" id="L147">                return 1;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            } else if (o1.getScore() == o2.getScore()) {</span>
<span class="nc" id="L149">                return 0;</span>
            } else {
<span class="nc" id="L151">                return -1;</span>
            }
        });

<span class="nc" id="L155">        final FinishedGameDTO finishedGame = new FinishedGameDTO(game.getDtoFactory().buildTeamDTOs(game.getTeams()), roundCounter / game.getNumberOfTeams(),</span>
<span class="nc" id="L156">            getTotalNumberOfCorrectExpressions(), getTotalNumberOfWrongExpressions(), endTime - gameStartTime);</span>

<span class="nc" id="L158">        game.getWebSocketService().sendFinishGameToFrontend(game.getGameCode(), finishedGame, earlyFinish);</span>
<span class="nc" id="L159">        game.persistFinishedGame();</span>
<span class="nc" id="L160">        game.getLobbyService().closeFinishedGame(game.getGameCode());</span>
<span class="nc" id="L161">    }</span>

    /**
     * Method that updates the dices battery status
     */
    protected void updateDiceBattery(final int batteryStatus) {
<span class="fc" id="L167">        game.getDice().setBatteryPower(batteryStatus);</span>
<span class="fc" id="L168">        game.getWebSocketService().sendBatteryUpdateToFrontend(game.getGameCode(), new BatteryUpdateDTO(batteryStatus));</span>
<span class="fc" id="L169">    }</span>

    /**
     * Method that updates the dices connection status. Blocks active game flow if
     * dice is disconnected and starts a fresh round with a fresh expression upon
     * reconnection.
     */
    protected void updateDiceConnection(final boolean isConnected) {

<span class="fc" id="L178">        currentFacet = null;</span>
<span class="fc" id="L179">        roundStartTime = -1L;</span>
<span class="fc" id="L180">        roundEndTime = -1L;</span>

<span class="fc" id="L182">        game.getWebSocketService().sendConnectionUpdateToFrontend(game.getGameCode(), new DiceConnectionUpdateDTO(isConnected));</span>
<span class="fc" id="L183">        game.getDice().setRaspberryConnected(isConnected);</span>

<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (isConnected) {</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if (!pickNewExpression()) {</span>
<span class="nc" id="L187">                finishGame(true);</span>
            }
<span class="nc" id="L189">            expressionConfirmed = false;</span>
        }
<span class="fc" id="L191">        sendRunningDataToTeams();</span>
<span class="fc" id="L192">    }</span>

    /**
     * Method that calculates the total number of correct expressions.
     *
     * @return total number of correct expressions.
     */
    private int getTotalNumberOfCorrectExpressions() {
<span class="nc" id="L200">        int result = 0;</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">        for (final Team t : game.getTeams()) {</span>
<span class="nc" id="L202">            result += t.getNumberOfCorrectExpressions();</span>
<span class="nc" id="L203">        }</span>
<span class="nc" id="L204">        return result;</span>
    }

    /**
     * Method that calculates the total number of wrong expressions.
     *
     * @return total number of wrong expressions.
     */
    private int getTotalNumberOfWrongExpressions() {
<span class="nc" id="L213">        int result = 0;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        for (final Team t : game.getTeams()) {</span>
<span class="nc" id="L215">            result += t.getNumberOfCorrectExpressions();</span>
<span class="nc" id="L216">        }</span>
<span class="nc" id="L217">        return result;</span>
    }

    /**
     * Method that sends running game information to the teams. The currently
     * guessing team does not get information about the current expression;
     */
    private void sendRunningDataToTeams() {
<span class="fc bfc" id="L225" title="All 2 branches covered.">        for (final Team t : game.getTeams()) {</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">            if (currentTeam == t.getIndex()) {</span>
<span class="fc" id="L227">                game.getWebSocketService().sendRunningDataToTeam(game.getGameCode(), t.getIndex(), game.getDtoFactory().buildRunningDataDTO(game, true));</span>
            } else {
<span class="fc" id="L229">                game.getWebSocketService().sendRunningDataToTeam(game.getGameCode(), t.getIndex(), game.getDtoFactory().buildRunningDataDTO(game, false));</span>
            }
<span class="fc" id="L231">        }</span>
<span class="fc" id="L232">    }</span>

    /**
     * Method that picks a new random expression and adds it to the usedExpressions
     * list.
     *
     * @return true if expression could be found, false if no expressions are left.
     */
    private boolean pickNewExpression() {
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if (usedExpressions.size() == game.getExpressionService().getAllExpressionsByCategory(game.getCategory()).size()) {</span>
<span class="nc" id="L242">            return false;</span>
        } else {
            do {
<span class="fc" id="L245">                currentExpression = game.getExpressionService().getRandomExpressionByCategory(game.getCategory());</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">            } while (!usedExpressions.add(currentExpression.getId()));</span>
<span class="fc" id="L247">            return true;</span>
        }
    }

    /**
     * Method that correctly increments the current team.
     */
    private void incrementCurrentTeam() {
<span class="fc" id="L255">        currentTeam = (currentTeam + 1) % game.getTeams().size();</span>
<span class="fc" id="L256">    }</span>

    /**
     * Method that checks whether a user is in the currently guessing team.
     *
     * @param user user to check for
     * @return true if user is in the currently guessing team, else false.
     */
    protected boolean isUserInCurrentTeam(final User user) {
<span class="fc" id="L265">        return game.getTeams().get(currentTeam).getPlayers().contains(user);</span>
    }

    public User getCurrentPlayer() {
<span class="fc" id="L269">        return game.getTeams().get(currentTeam).getCurrentPlayer();</span>
    }

    public int getCurrentTeam() {
<span class="fc" id="L273">        return currentTeam;</span>
    }

    public int getRoundCounter() {
<span class="fc" id="L277">        return roundCounter;</span>
    }

    public Expression getCurrentExpression() {
<span class="fc" id="L281">        return currentExpression;</span>
    }

    public Integer getCurrentFacet() {
<span class="fc" id="L285">        return currentFacet;</span>
    }

    public Long getRoundStartTime() {
<span class="fc" id="L289">        return roundStartTime;</span>
    }

    public Long getRoundEndTime() {
<span class="fc" id="L293">        return roundEndTime;</span>
    }

    public long getGameStartTime() {
<span class="fc" id="L297">        return gameStartTime;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>